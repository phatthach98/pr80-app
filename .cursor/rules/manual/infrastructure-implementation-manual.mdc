---
description: 
globs: 
alwaysApply: false
---

# Infrastructure Layer Implementation Rule

## Context

- This rule applies when implementing repository or service classes in the infrastructure layer
- The infrastructure layer implements interfaces defined in the application layer
- Each implementation should only reference the specific entity it's responsible for
- Following clean architecture principles, inner layers (domain, application) should never depend on outer layers (infrastructure)

## Critical Rules

- Repository implementations MUST implement interfaces from the application layer
- Import ONLY the specific entity from domain layer that the repository is responsible for
- Use MongoDB schemas directly without constructor injection to simplify implementation
- Return domain entities from repository methods, not database models
- Handle errors appropriately within the implementation
- Map database models to domain entities when returning data
- Follow the naming convention: `{EntityName}RepositoryImpl` for repository implementations
- Register implementations in the DI container with corresponding tokens

## Examples

<example>
// Good implementation - imports only what's needed and uses schema directly
import { DishOptionRepository } from "@application/interface/repository/dish-option-repo.interface";
import { DishOption } from "@domain/entity/dish-option";
import { DishOptionSchema } from "../schemas/dish-option-schema";

export class DishOptionRepositoryImpl implements DishOptionRepository {
  // No constructor injection - using schema directly
  
  async getDishOptionById(id: string): Promise<DishOption | null> {
    try {
      const dishOption = await DishOptionSchema.findOne({ id }).lean();
      
      if (!dishOption) {
        return null;
      }

      return new DishOption(
        dishOption.id,
        dishOption.name,
        dishOption.description,
        dishOption.options
      );
    } catch (error) {
      console.error("Error fetching dish option by ID:", error);
      return null;
    }
  }
}
</example>

<example type="invalid">
// Bad implementation - imports too many entities and doesn't follow clean architecture
import { DishOptionRepository } from "@application/interface/repository/dish-option-repo.interface";
import { DishOption } from "@domain/entity/dish-option";
import { Dish } from "@domain/entity/dish"; // Importing unrelated entity
import { User } from "@domain/entity/user"; // Importing unrelated entity
import { DishOptionSchema } from "../schemas/dish-option-schema";

// Missing implementation of interface
export class DishOptionRepositoryImpl {
  // Unnecessary constructor when we could use schema directly
  constructor(private readonly dishOptionModel = DishOptionSchema) {}
  
  // Returning raw database model instead of domain entity
  async getDishOptionById(id: string): Promise<any> {
    return this.dishOptionModel.findOne({ id });
  }
}
</example>